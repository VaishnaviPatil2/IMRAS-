const cron = require('node-cron');
const { StockLocation, Item, Warehouse, Supplier, PurchaseRequest, PurchaseOrder, User } = require('../models');

class AutomaticTriggerService {
  
  static isRunning = false;
  static cronJob = null;

  // Start automatic triggers
  static startAutomaticTriggers() {
    if (this.isRunning) return;

    console.log('Starting Automatic PR/PO Trigger Service...');
    
    this.cronJob = cron.schedule('*/5 * * * *', async () => {
      await this.executeAutomaticCheck();
    }, {
      scheduled: false
    });

    this.cronJob.start();
    this.isRunning = true;
    console.log('Automatic triggers started - Running every 5 minutes');
  }

  // Stop automatic triggers
  static stopAutomaticTriggers() {
    if (this.cronJob) {
      this.cronJob.stop();
      this.cronJob = null;
    }
    this.isRunning = false;
  }

  // Execute the automatic check
  static async executeAutomaticCheck() {
    try {
      console.log('[AUTO] Running scheduled stock check...', new Date().toLocaleString());
      
      const allStockLocations = await StockLocation.findAll({
        where: { isActive: true },
        include: [
          {
            model: Item,
            as: 'item',
            where: { isActive: true },
            attributes: ['id', 'sku', 'name', 'reorderPoint', 'safetyStock', 'leadTimeDays', 'dailyConsumption', 'unitPrice']
          },
          {
            model: Warehouse,
            as: 'warehouse',
            where: { isActive: true }
          }
        ]
      });

      const lowStockLocations = allStockLocations.filter(location => {
        const item = location.item;
        const itemReorderThreshold = item.reorderPoint || 0;
        const effectiveMinimum = Math.max(location.minStock || 0, itemReorderThreshold);
        return location.currentStock <= effectiveMinimum;
      });

      if (lowStockLocations.length === 0) {
        return;
      }

      let prsCreated = 0;
      let prsAutoApproved = 0;
      let prsSkipped = 0;
      let posCreated = 0;
      let errors = [];

      for (const location of lowStockLocations) {
        try {
          const result = await this.processLowStockLocationAuto(location);
          if (result.prCreated) prsCreated++;
          if (result.autoApproved) prsAutoApproved++;
          if (result.skipped) prsSkipped++;
          if (result.poCreated) posCreated++;
        } catch (error) {
          errors.push(`Location ${location.id}: ${error.message}`);
        }
      }

      if (prsCreated > 0 || posCreated > 0) {
        console.log(`[AUTO] Created: ${prsCreated} PRs, ${posCreated} POs`);
      }

      return {
        prsCreated,
        prsAutoApproved,
        prsSkipped,
        posCreated,
        errors,
        success: true
      };

    } catch (error) {
      return {
        prsCreated: 0,
        prsAutoApproved: 0,
        prsSkipped: 0,
        posCreated: 0,
        errors: [error.message],
        success: false
      };
    }
  }

  // Process individual low stock location (same logic as manual trigger)
  static async processLowStockLocationAuto(location) {
    try {
      const item = location.item;
      const warehouse = location.warehouse;
      
      const existingPR = await PurchaseRequest.findOne({
        where: {
          itemId: item.id,
          warehouseId: warehouse.id,
          status: ['pending', 'approved'],
          isAutoGenerated: true
        }
      });

      if (existingPR) {
        return { prCreated: false, poCreated: false, skipped: true };
      }

      const lastPR = await PurchaseRequest.findOne({
        where: {
          itemId: item.id,
          warehouseId: warehouse.id,
          isAutoGenerated: true
        },
        order: [['createdAt', 'DESC']]
      });

      if (lastPR) {
        const daysSinceLastPR = (Date.now() - new Date(lastPR.createdAt)) / (1000 * 60 * 60 * 24);
        const minDaysBetweenOrders = 7;
        
        if (daysSinceLastPR < minDaysBetweenOrders && lastPR.status === 'converted_to_po') {
          return { prCreated: false, poCreated: false, skipped: true };
        }
      }

      const systemUser = await User.findOne({
        where: { role: 'admin' },
        order: [['createdAt', 'ASC']]
      });

      if (!systemUser) {
        throw new Error('No admin user found');
      }

      const currentStock = location.currentStock || 0;
      const minStock = location.minStock || 0;
      const maxStock = location.maxStock || 0;
      
      const requiredQuantity = Math.max(1, maxStock - currentStock);
      
      const effectiveMinimum = Math.max(location.minStock || 0, item.reorderPoint || 0);
      
      let urgencyLevel = 'medium';
      if (location.currentStock === 0) {
        urgencyLevel = 'urgent';
      } else if (location.currentStock <= (effectiveMinimum * 0.5)) {
        urgencyLevel = 'high';
      }

      const pr = await PurchaseRequest.create({
        itemId: item.id,
        warehouseId: warehouse.id,
        requestedQuantity: requiredQuantity,
        urgencyLevel: urgencyLevel,
        reason: urgencyLevel === 'urgent' ? 'out_of_stock' : 'low_stock',
        status: 'pending',
        notes: `${urgencyLevel === 'urgent' ? 'URGENT' : urgencyLevel === 'high' ? 'HIGH' : 'MEDIUM'} Auto-generated PR (AUTOMATIC TRIGGER) - Current: ${location.currentStock}, Min: ${location.minStock}, Max: ${location.maxStock}`,
        requestedById: systemUser.id,
        isAutoGenerated: true
      });

      if (urgencyLevel === 'urgent' || urgencyLevel === 'high') {
        await pr.update({
          status: 'approved',
          approvedById: systemUser.id,
          approvedAt: new Date()
        });

        try {
          const supplier = await Supplier.findOne({
            order: [['leadTimeDays', 'ASC']]
          });

          if (supplier) {
            const fullItem = await Item.findByPk(item.id, {
              attributes: ['id', 'sku', 'name', 'unitPrice', 'reorderPoint', 'safetyStock']
            });
            
            if (!fullItem || !fullItem.unitPrice) {
              return { prCreated: true, poCreated: false, autoApproved: true };
            }
            
            const unitPrice = fullItem.unitPrice;
            const totalAmount = pr.requestedQuantity * unitPrice;
            
            const poCount = await PurchaseOrder.count();
            const poNumber = `PO${String(poCount + 1).padStart(6, '0')}`;

            const expectedDeliveryDate = new Date();
            expectedDeliveryDate.setDate(expectedDeliveryDate.getDate() + (supplier.leadTimeDays || 7));

            const po = await PurchaseOrder.create({
              poNumber: poNumber,
              prId: pr.id,
              supplierId: supplier.id,
              itemId: pr.itemId,
              warehouseId: pr.warehouseId,
              orderedQuantity: pr.requestedQuantity,
              unitPrice: unitPrice,
              totalAmount: totalAmount,
              priority: pr.urgencyLevel,
              status: 'draft',
              expectedDeliveryDate: expectedDeliveryDate,
              notes: `Auto-generated PO from PR ${pr.prNumber} (AUTOMATIC TRIGGER) - Priority: ${pr.urgencyLevel.toUpperCase()}`,
              createdById: systemUser.id,
              isAutoGenerated: true
            });

            await pr.update({ status: 'converted_to_po' });

            if (urgencyLevel === 'urgent') {
              await po.update({
                status: 'sent',
                sentAt: new Date()
              });
            }

            return { prCreated: true, poCreated: true, autoApproved: true };
          }
        } catch (poError) {
          return { prCreated: true, poCreated: false, autoApproved: true };
        }
      } else {
        return { prCreated: true, poCreated: false, autoApproved: false };
      }

    } catch (error) {
      throw error;
    }
  }

  // Get status of automatic triggers
  static getStatus() {
    return {
      isRunning: this.isRunning,
      nextRun: this.cronJob ? 'Every 2 minutes' : 'Not scheduled',
      lastCheck: 'Check logs for last execution time'
    };
  }
}

module.exports = AutomaticTriggerService;