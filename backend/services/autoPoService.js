const { StockLocation, Item, Warehouse, Supplier, PurchaseRequest, PurchaseOrder, User, Category, SupplierItem, sequelize } = require('../models');
const { Op } = require('sequelize');

// Utility functions for stock calculations (shared logic)
const calculateEffectiveMinimum = (stockLocation, item) => {
  const itemReorderThreshold = (item.reorderPoint || 0) + (item.safetyStock || 0);
  const locationMinStock = stockLocation.minStock || 0;
  return Math.max(locationMinStock, itemReorderThreshold);
};

const calculateUrgencyLevel = (stockLocation, item) => {
  const currentStock = stockLocation.currentStock || 0;
  const effectiveMinimum = calculateEffectiveMinimum(stockLocation, item);
  
  if (currentStock === 0) {
    return 'urgent';          // OUT OF STOCK - Emergency!
  } else if (currentStock <= (effectiveMinimum * 0.5)) {
    return 'high';            // ‚â§ 50% of minimum - High priority
  } else if (currentStock <= effectiveMinimum) {
    return 'medium';          // ‚â§ minimum threshold - Standard
  } else {
    return 'low';             // Above minimum - Low urgency
  }
};

// Standardized priority mapping for consistency across modules
const PRIORITY_LEVELS = {
  URGENT: 'urgent',
  HIGH: 'high', 
  MEDIUM: 'medium',
  LOW: 'low'
};

// Convert urgency to standard priority format
const standardizePriority = (urgencyOrPriority) => {
  const normalized = (urgencyOrPriority || '').toLowerCase();
  switch (normalized) {
    case 'urgent':
    case 'critical':
    case 'emergency':
      return PRIORITY_LEVELS.URGENT;
    case 'high':
    case 'important':
      return PRIORITY_LEVELS.HIGH;
    case 'medium':
    case 'normal':
    case 'standard':
      return PRIORITY_LEVELS.MEDIUM;
    case 'low':
    case 'minor':
      return PRIORITY_LEVELS.LOW;
    default:
      return PRIORITY_LEVELS.MEDIUM; // Default fallback
  }
};

class AutoPOService {
  
  // Check for low stock items and generate PRs/POs
  static async checkLowStockAndGeneratePO() {
    try {
      console.log('üîç Checking for low stock items...');
      
      // Find all active stock locations with their items
      const allStockLocations = await StockLocation.findAll({
        where: {
          isActive: true
        },
        include: [
          {
            model: Item,
            as: 'item',
            where: { isActive: true },
            attributes: ['id', 'sku', 'name', 'reorderPoint', 'safetyStock', 'leadTimeDays'],
            include: [
              {
                model: Category,
                as: 'category'
              }
            ]
          },
          {
            model: Warehouse,
            as: 'warehouse',
            where: { isActive: true }
          }
        ]
      });

      // Filter for low stock using proper reorder logic
      const lowStockLocations = allStockLocations.filter(location => {
        const item = location.item;
        
        // Calculate total reorder threshold: Item's reorderPoint + safetyStock
        const itemReorderThreshold = (item.reorderPoint || 0) + (item.safetyStock || 0);
        
        // Use the higher of: location minStock OR item reorder threshold
        const effectiveMinimum = Math.max(location.minStock || 0, itemReorderThreshold);
        
        // Item is low stock if current stock <= effective minimum
        return location.currentStock <= effectiveMinimum;
      });

      console.log(`üìä Found ${lowStockLocations.length} low stock locations (using Item reorderPoint + safetyStock)`);

      for (const location of lowStockLocations) {
        await this.processLowStockLocation(location);
      }

      return {
        success: true,
        processedLocations: lowStockLocations.length,
        message: `Processed ${lowStockLocations.length} low stock locations`
      };

    } catch (error) {
      console.error('‚ùå Error in checkLowStockAndGeneratePO:', error);
      throw error;
    }
  }

  // Process individual low stock location
  static async processLowStockLocation(location) {
    try {
      const item = location.item;
      const warehouse = location.warehouse;
      
      // Check if there's already a pending PR for this item and warehouse
      const existingPR = await PurchaseRequest.findOne({
        where: {
          itemId: item.id,
          warehouseId: warehouse.id,
          status: ['pending', 'approved'],
          isAutoGenerated: true
        }
      });

      if (existingPR) {
        console.log(`‚è≠Ô∏è Skipping - PR already exists for ${item.name} at ${warehouse.name}`);
        return;
      }

      // Calculate required quantity (max stock - current stock + safety buffer)
      const requiredQuantity = Math.max(
        location.maxStock - location.currentStock,
        item.reorderPoint
      );

      // Determine urgency based on effective minimum threshold using utility function
      const urgencyLevel = standardizePriority(calculateUrgencyLevel(location, item));

      // Find system user for auto-generation (admin or first admin user)
      const systemUser = await User.findOne({
        where: { role: 'admin' },
        order: [['createdAt', 'ASC']]
      });

      if (!systemUser) {
        console.error('‚ùå No admin user found for auto-generation');
        return;
      }

      // Create Purchase Request
      const pr = await PurchaseRequest.create({
        itemId: item.id,
        warehouseId: warehouse.id,
        requestedQuantity: requiredQuantity,
        urgencyLevel: urgencyLevel,
        reason: location.currentStock === 0 ? 'out_of_stock' : 'low_stock',
        status: 'pending',
        notes: `Auto-generated PR - Current stock: ${location.currentStock}, Min stock: ${location.minStock}, Max stock: ${location.maxStock}`,
        requestedById: systemUser.id,
        isAutoGenerated: true
      });

      console.log(`‚úÖ Created PR ${pr.prNumber} for ${item.name} at ${warehouse.name}`);

      // Auto-approve PR if urgency is urgent or high
      if (urgencyLevel === 'urgent' || urgencyLevel === 'high') {
        await this.autoApprovePR(pr, systemUser.id);
      }

    } catch (error) {
      console.error('‚ùå Error processing low stock location:', error);
      throw error;
    }
  }

  // Auto-approve PR and generate PO
  static async autoApprovePR(pr, userId) {
    try {
      // Update PR status
      await pr.update({
        status: 'approved',
        approvedById: userId,
        approvedAt: new Date()
      });

      console.log(`‚úÖ Auto-approved PR ${pr.prNumber}`);

      // Generate PO automatically
      await this.generatePOFromPR(pr, userId);

    } catch (error) {
      console.error('‚ùå Error auto-approving PR:', error);
      throw error;
    }
  }

  // Generate PO from approved PR
  static async generatePOFromPR(pr, userId, isAutoGenerated = true) {
    try {
      let supplier;
      
      // Use preferred supplier if specified in PR, otherwise use item's preferred supplier
      if (pr.preferredSupplierId) {
        supplier = await Supplier.findByPk(pr.preferredSupplierId);
        if (supplier) {
          console.log(`‚úÖ Using PR preferred supplier: ${supplier.name}`);
        } else {
          console.log(`‚ö†Ô∏è PR preferred supplier ${pr.preferredSupplierId} not found, checking item's preferred supplier...`);
        }
      }
      
      // If no PR preferred supplier or not found, check item's preferred supplier
      if (!supplier) {
        const item = await Item.findByPk(pr.itemId, {
          include: [{ model: Supplier, as: 'preferredSupplier' }]
        });
        
        if (item?.preferredSupplier) {
          supplier = item.preferredSupplier;
          console.log(`‚úÖ Using item's preferred supplier: ${supplier.name}`);
        }
      }
      
      // Auto-select supplier if no preferred supplier found
      if (!supplier) {
        supplier = await Supplier.findOne({
          order: [
            ['leadTimeDays', 'ASC'],      // 1st Priority: Fastest delivery
            ['pricingTier', 'ASC'],       // 2nd Priority: Better pricing
            ['createdAt', 'ASC']          // 3rd Priority: Established suppliers
          ]
        });
        
        if (supplier) {
          console.log(`ü§ñ Auto-selected supplier: ${supplier.name} (Lead time: ${supplier.leadTimeDays} days)`);
        }
      }

      if (!supplier) {
        throw new Error('No suppliers found. Please add at least one supplier before creating purchase orders.');
      }

      // Calculate expected delivery date
      const expectedDeliveryDate = new Date();
      expectedDeliveryDate.setDate(expectedDeliveryDate.getDate() + supplier.leadTimeDays);

      // Use item's unit price if available, otherwise default
      const item = await Item.findByPk(pr.itemId);
      const unitPrice = item?.unitPrice || 10.00;

      // Create Purchase Order
      const po = await PurchaseOrder.create({
        prId: pr.id,
        supplierId: supplier.id,
        itemId: pr.itemId,
        warehouseId: pr.warehouseId,
        orderedQuantity: pr.requestedQuantity,
        unitPrice: unitPrice,
        priority: pr.urgencyLevel,
        expectedDeliveryDate: expectedDeliveryDate,
        notes: `${isAutoGenerated ? 'Auto-generated' : 'Manual'} PO from PR ${pr.prNumber}`,
        createdById: userId,
        isAutoGenerated: isAutoGenerated
      });

      // ‚úÖ FIXED: Only update PR status for auto-generated POs
      // Manual PO creation should not change PR status
      if (isAutoGenerated) {
        await pr.update({
          status: 'converted_to_po'
        });
        console.log(`‚úÖ Auto-generated PO ${po.poNumber} from PR ${pr.prNumber} - PR status updated`);
      } else {
        console.log(`‚úÖ Manual PO ${po.poNumber} created from PR ${pr.prNumber} - PR status unchanged`);
      }

      // Auto-send PO if urgency is urgent
      if (pr.urgencyLevel === 'urgent') {
        await this.autoSendPO(po);
      }

      return po;

    } catch (error) {
      console.error('‚ùå Error generating PO from PR:', error);
      throw error;
    }
  }

  // Auto-send PO to supplier
  static async autoSendPO(po) {
    try {
      await po.update({
        status: 'sent',
        sentAt: new Date()
      });

      console.log(`üìß Auto-sent PO ${po.poNumber} to supplier`);

      // Send email notification to supplier
      await this.sendPOEmailToSupplier(po);

    } catch (error) {
      console.error('‚ùå Error auto-sending PO:', error);
      throw error;
    }
  }

  // Send PO email to supplier
  static async sendPOEmailToSupplier(po) {
    try {
      // Get full PO details with supplier info
      const fullPO = await PurchaseOrder.findByPk(po.id, {
        include: [
          { model: Item, as: 'item' },
          { model: Warehouse, as: 'warehouse' },
          { model: Supplier, as: 'supplier' }
        ]
      });

      if (!fullPO || !fullPO.supplier) {
        console.error('‚ùå PO or supplier not found for email');
        return;
      }

      const approvalLink = `${process.env.BASE_URL}/suppliers?po=${po.id}`;
      
      const emailContent = `
        Dear ${fullPO.supplier.name},

        Purchase Order ${fullPO.poNumber} requires your approval.

        ORDER DETAILS:
        - Item: ${fullPO.item.name} (${fullPO.item.sku})
        - Quantity: ${fullPO.orderedQuantity} units
        - Unit Price: $${fullPO.unitPrice}
        - Total Amount: $${fullPO.totalAmount}
        - Priority: ${fullPO.priority.toUpperCase()}
        - Expected Delivery: ${fullPO.expectedDeliveryDate ? new Date(fullPO.expectedDeliveryDate).toLocaleDateString() : 'TBD'}
        - Delivery Location: ${fullPO.warehouse.name}

        ACTIONS REQUIRED:
        ‚úÖ Accept Order
        ‚ùå Reject Order  
        ‚è∞ Request Delay

        Click here to review and respond:
        ${approvalLink}

        Note: This link expires in 48 hours.

        Best regards,
        IMRAS Procurement System
      `;

      const sendEmail = require('../utils/sendEmail');
      await sendEmail(
        fullPO.supplier.email,
        `üîî PO Approval Required - ${fullPO.poNumber}`,
        emailContent
      );

      console.log(`‚úÖ Email sent to supplier: ${fullPO.supplier.email}`);

    } catch (error) {
      console.error('‚ùå Error sending PO email:', error);
      // Don't throw error - email failure shouldn't break PO creation
    }
  }

  // Get low stock summary
  static async getLowStockSummary() {
    try {
      // Get all active stock locations with their items
      const allStockLocations = await StockLocation.findAll({
        where: {
          isActive: true
        },
        include: [
          {
            model: Item,
            as: 'item',
            where: { isActive: true },
            attributes: ['id', 'sku', 'name', 'reorderPoint', 'safetyStock']
          },
          {
            model: Warehouse,
            as: 'warehouse',
            where: { isActive: true }
          }
        ]
      });

      // Filter for low stock using proper reorder logic
      const lowStockLocations = allStockLocations.filter(location => {
        const item = location.item;
        
        // Calculate total reorder threshold: Item's reorderPoint + safetyStock
        const itemReorderThreshold = (item.reorderPoint || 0) + (item.safetyStock || 0);
        
        // Use the higher of: location minStock OR item reorder threshold
        const effectiveMinimum = Math.max(location.minStock || 0, itemReorderThreshold);
        
        // Item is low stock if current stock <= effective minimum
        return location.currentStock <= effectiveMinimum;
      });

      const summary = {
        totalLowStockItems: lowStockLocations.length,
        criticalItems: lowStockLocations.filter(loc => loc.currentStock === 0).length,
        lowStockItems: lowStockLocations.filter(loc => loc.currentStock > 0).length,
        locations: lowStockLocations.map(loc => {
          const item = loc.item;
          const itemReorderThreshold = (item.reorderPoint || 0) + (item.safetyStock || 0);
          const effectiveMinimum = Math.max(loc.minStock || 0, itemReorderThreshold);
          
          return {
            id: loc.id,
            itemName: item.name,
            itemSku: item.sku,
            warehouseName: loc.warehouse.name,
            currentStock: loc.currentStock,
            minStock: loc.minStock,
            maxStock: loc.maxStock,
            itemReorderPoint: item.reorderPoint,
            itemSafetyStock: item.safetyStock,
            effectiveMinimum: effectiveMinimum,
            status: loc.currentStock === 0 ? 'out_of_stock' : 'low_stock'
          };
        })
      };

      return summary;

    } catch (error) {
      console.error('‚ùå Error getting low stock summary:', error);
      throw error;
    }
  }
}

module.exports = AutoPOService;