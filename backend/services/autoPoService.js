const { StockLocation, Item, Warehouse, Supplier, PurchaseRequest, PurchaseOrder, User } = require('../models');

// Auto PO Service
async function checkLowStockAndGeneratePR() {
  try {
    console.log('Checking for low stock items and generating PRs...');
    
    // Find all active stock locations with their items
    const allStockLocations = await StockLocation.findAll({
      where: { isActive: true },
      include: [
        {
          model: Item,
          as: 'item',
          where: { isActive: true },
          attributes: ['id', 'sku', 'name', 'reorderPoint', 'safetyStock', 'leadTimeDays', 'dailyConsumption', 'unitPrice']
        },
        {
          model: Warehouse,
          as: 'warehouse',
          where: { isActive: true }
        }
      ]
    });

    // Filter for low stock using proper reorder logic
    const lowStockLocations = allStockLocations.filter(location => {
      const item = location.item;
      // Use reorderPoint directly as it already includes safetyStock in scientific formula
      const itemReorderThreshold = item.reorderPoint || 0;
      const effectiveMinimum = Math.max(location.minStock || 0, itemReorderThreshold);
      return location.currentStock <= effectiveMinimum;
    });

    console.log(`Found ${lowStockLocations.length} low stock locations`);

    let totalPRsCreated = 0;
    let totalPOsCreated = 0;
    let prsAutoApproved = 0;
    let prsSkipped = 0;
    let errors = [];

    for (const location of lowStockLocations) {
      try {
        const result = await processLowStockLocation(location);
        if (result.prCreated) totalPRsCreated++;
        if (result.poCreated) totalPOsCreated++;
        if (result.autoApproved) prsAutoApproved++;
        if (result.skipped) prsSkipped++;
      } catch (error) {
        console.error(`Error processing location ${location.id}:`, error.message);
        errors.push(`Location ${location.id}: ${error.message}`);
      }
    }

    return {
      success: true,
      processedLocations: lowStockLocations.length,
      summary: { 
        prsCreated: totalPRsCreated, 
        prsAutoApproved: prsAutoApproved,
        prsSkipped: prsSkipped,
        posCreated: totalPOsCreated,
        lowStockLocationsFound: lowStockLocations.length,
        totalLocationsChecked: allStockLocations.length,
        errors: errors
      },
      message: `Generated ${totalPRsCreated} PRs and ${totalPOsCreated} POs`
    };

  } catch (error) {
    console.error('Error in checkLowStockAndGeneratePR:', error);
    throw error;
  }
}

async function processLowStockLocation(location) {
  try {
    const item = location.item;
    const warehouse = location.warehouse;
    
    // Check if PR already exists within last 7 days
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    
    const existingPR = await PurchaseRequest.findOne({
      where: {
        itemId: item.id,
        warehouseId: warehouse.id,
        status: ['pending', 'approved', 'converted_to_po'],
        isAutoGenerated: true,
        createdAt: {
          [require('sequelize').Op.gte]: sevenDaysAgo
        }
      }
    });

    if (existingPR) {
      console.log(`Skipping - Recent PR exists for ${item.name} at ${warehouse.name} (Created: ${existingPR.createdAt})`);
      return { prCreated: false, poCreated: false, skipped: true };
    }

    // Find admin user
    const systemUser = await User.findOne({
      where: { role: 'admin' },
      order: [['createdAt', 'ASC']]
    });

    if (!systemUser) {
      throw new Error('No admin user found');
    }

    // Min-Max System Required Quantity Calculation
    const currentStock = location.currentStock || 0;
    const minStock = location.minStock || 0;
    const maxStock = location.maxStock || 0;
    
    const requiredQuantity = Math.max(1, maxStock - currentStock);
    
    console.log(`[MIN-MAX] Item: ${item.name}, Current: ${currentStock}, Min: ${minStock}, Max: ${maxStock}, Required: ${requiredQuantity}`);

    // Determine urgency based on industry standard logic
    const effectiveMinimum = Math.max(location.minStock || 0, item.reorderPoint || 0);
    
    let urgencyLevel = 'medium';
    if (location.currentStock === 0) {
      urgencyLevel = 'urgent';
    } else if (location.currentStock <= (effectiveMinimum * 0.5)) {
      urgencyLevel = 'high';
    }

    // Create PR first
    const pr = await PurchaseRequest.create({
      itemId: item.id,
      warehouseId: warehouse.id,
      requestedQuantity: requiredQuantity,
      urgencyLevel: urgencyLevel,
      reason: urgencyLevel === 'urgent' ? 'out_of_stock' : 'low_stock',
      status: 'pending',
      notes: `${urgencyLevel === 'urgent' ? 'URGENT' : urgencyLevel === 'high' ? 'HIGH' : 'MEDIUM'} Auto-generated PR - Current: ${location.currentStock}, Min: ${location.minStock}, Max: ${location.maxStock}`,
      requestedById: systemUser.id,
      isAutoGenerated: true
    });

    console.log(`Created PR ${pr.prNumber} for ${item.name} (${urgencyLevel.toUpperCase()})`);

    // Apply industry standard logic based on priority
    if (urgencyLevel === 'urgent' || urgencyLevel === 'high') {
      // Auto approve for URGENT and HIGH priority
      await pr.update({
        status: 'approved',
        approvedById: systemUser.id,
        approvedAt: new Date()
      });
      console.log(`Auto-approved ${urgencyLevel.toUpperCase()} PR ${pr.prNumber}`);

      // Create PO for approved PR
      const po = await generatePOFromPR(pr, systemUser.id);
      console.log(`Auto-created PO ${po.poNumber} for ${urgencyLevel.toUpperCase()} PR`);

      // For URGENT: Auto send to supplier
      if (urgencyLevel === 'urgent') {
        await po.update({
          status: 'sent',
          sentAt: new Date()
        });
        console.log(`URGENT PO ${po.poNumber} sent directly to supplier`);
        return { prCreated: true, poCreated: true, autoSent: true, autoApproved: true };
      } else {
        console.log(`HIGH PO ${po.poNumber} created - Awaiting admin approval`);
        return { prCreated: true, poCreated: true, awaitingApproval: true, autoApproved: true };
      }
    } else {
      console.log(`MEDIUM PR ${pr.prNumber} created - Awaiting manager approval`);
      return { prCreated: true, poCreated: false, awaitingManagerApproval: true };
    }

  } catch (error) {
    console.error('Error processing low stock location:', error);
    throw error;
  }
}
async function generatePOFromPR(pr, userId, shouldUpdatePRStatus = true) {
  try {
    console.log(`Generating PO from PR ${pr.prNumber || pr.id}...`);
    
    // Find a supplier for the item
    let supplier = await Supplier.findOne({
      order: [['leadTimeDays', 'ASC']]
    });

    if (!supplier) {
      throw new Error('No active suppliers found');
    }

    // Get item details
    const fullItem = await Item.findByPk(pr.itemId, {
      attributes: ['id', 'sku', 'name', 'unitPrice', 'reorderPoint', 'safetyStock']
    });
    
    if (!fullItem) {
      throw new Error('Item not found');
    }

    if (!fullItem.unitPrice) {
      throw new Error(`Unit price not set for item: ${fullItem.name} (${fullItem.sku}). Please set unit price in Item Catalog.`);
    }

    const unitPrice = fullItem.unitPrice;
    const totalAmount = pr.requestedQuantity * unitPrice;
    
    // Generate PO number
    const poCount = await PurchaseOrder.count();
    const poNumber = `PO${String(poCount + 1).padStart(6, '0')}`;

    // Calculate delivery date
    const expectedDeliveryDate = new Date();
    expectedDeliveryDate.setDate(expectedDeliveryDate.getDate() + (supplier.leadTimeDays || 7));

    // Create PO
    const po = await PurchaseOrder.create({
      poNumber: poNumber,
      prId: pr.id,
      supplierId: supplier.id,
      itemId: pr.itemId,
      warehouseId: pr.warehouseId,
      orderedQuantity: pr.requestedQuantity,
      unitPrice: unitPrice,
      totalAmount: totalAmount,
      priority: pr.urgencyLevel,
      status: 'draft',
      expectedDeliveryDate: expectedDeliveryDate,
      notes: `Auto-generated PO from PR ${pr.prNumber || pr.id} - Priority: ${pr.urgencyLevel.toUpperCase()}`,
      createdById: userId,
      isAutoGenerated: pr.isAutoGenerated || false
    });

    // Update PR status to indicate it's been converted
    if (shouldUpdatePRStatus) {
      await pr.update({ status: 'converted_to_po' });
    }

    console.log(`Created PO ${po.poNumber} from PR ${pr.prNumber || pr.id}`);
    return po;

  } catch (error) {
    console.error('Error generating PO:', error);
    throw error;
  }
}

// Get low stock summary
async function getLowStockSummary() {
  try {
    const allStockLocations = await StockLocation.findAll({
      where: { isActive: true },
      include: [
        {
          model: Item,
          as: 'item',
          where: { isActive: true },
          attributes: ['id', 'sku', 'name', 'reorderPoint', 'safetyStock', 'unitPrice']
        },
        {
          model: Warehouse,
          as: 'warehouse',
          where: { isActive: true }
        }
      ]
    });

    const lowStockLocations = allStockLocations.filter(location => {
      const item = location.item;
      const itemReorderThreshold = item.reorderPoint || 0;
      const effectiveMinimum = Math.max(location.minStock || 0, itemReorderThreshold);
      return location.currentStock <= effectiveMinimum;
    });

    return {
      totalLocations: allStockLocations.length,
      lowStockCount: lowStockLocations.length,
      lowStockLocations: lowStockLocations.map(loc => ({
        id: loc.id,
        item: loc.item.name,
        warehouse: loc.warehouse.name,
        currentStock: loc.currentStock,
        minStock: loc.minStock,
        maxStock: loc.maxStock,
        reorderPoint: loc.item.reorderPoint
      }))
    };
  } catch (error) {
    console.error('Error getting low stock summary:', error);
    throw error;
  }
}

// Legacy method for backward compatibility
async function checkLowStockAndGeneratePO() {
  return await checkLowStockAndGeneratePR();
}

// Export functions
module.exports = {
  checkLowStockAndGeneratePR,
  checkLowStockAndGeneratePO,
  processLowStockLocation,
  generatePOFromPR,
  getLowStockSummary
};