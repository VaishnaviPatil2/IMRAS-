const express = require("express");
const router = express.Router();
const { Op } = require("sequelize");

const { User, Category, Item, Warehouse, StockLocation, TransferOrder, PurchaseRequest, PurchaseOrder, GRN, Supplier } = require("../models");

const { verifyUser } = require("../middleware/authMiddleware");

router.get("/", verifyUser, async (req, res) => {
  try {
    console.log(`Dashboard request from user: ${req.user.role} (ID: ${req.user.id})`);
    const startTime = Date.now();
    
    const role = req.user.role;

    // Optimize queries by running them in parallel
    const [
      totalUsers,
      totalCategories,
      totalItems,
      totalWarehouses,
      totalStockLocations,
      totalSuppliers,
      allStockLocations,
      transferOrdersPending,
      transferOrdersApproved,
      transferOrdersRejected,
      transferOrdersCompleted,
      transferOrdersCancelled,
      totalPRs,
      pendingPRs,
      approvedPRs,
      rejectedPRs,
      convertedPRs,
      autoPRs,
      manualPRs,
      totalPOs,
      draftPOs,
      sentPOs,
      acknowledgedPOs,
      completedPOs,
      cancelledPOs,
      autoPOs,
      manualPOs,
      totalGRNs,
      pendingGRNs,
      approvedGRNs,
      adminUsers,
      managerUsers,
      warehouseUsers,
      supplierUsers
    ] = await Promise.all([
      // USERS
      User.count(),
      
      // CATEGORIES & ITEMS
      Category.count(),
      Item.count(),
      
      // WAREHOUSES
      Warehouse.count(),
      
      // STOCK LOCATIONS
      StockLocation.count(),
      
      // SUPPLIERS
      Supplier.count(),
      
      // LOW STOCK - get all stock locations with includes
      StockLocation.findAll({
        where: { isActive: true },
        include: [
          { 
            model: Item, 
            as: 'item', 
            attributes: ['name', 'sku', 'reorderPoint', 'safetyStock', 'dailyConsumption'],
            where: { isActive: true }
          },
          { 
            model: Warehouse, 
            as: 'warehouse', 
            attributes: ['name', 'code'],
            where: { isActive: true }
          }
        ]
      }),
      
      // TRANSFER ORDERS
      TransferOrder.count({ where: { status: "pending" } }),
      TransferOrder.count({ where: { status: "approved" } }),
      TransferOrder.count({ where: { status: "rejected" } }),
      TransferOrder.count({ where: { status: "completed" } }),
      TransferOrder.count({ where: { status: "cancelled" } }),
      
      // PURCHASE REQUESTS
      PurchaseRequest.count(),
      PurchaseRequest.count({ where: { status: "pending" } }),
      PurchaseRequest.count({ where: { status: "approved" } }),
      PurchaseRequest.count({ where: { status: "rejected" } }),
      PurchaseRequest.count({ where: { status: "converted_to_po" } }),
      PurchaseRequest.count({ where: { isAutoGenerated: true } }),
      PurchaseRequest.count({ where: { isAutoGenerated: false } }),
      
      // PURCHASE ORDERS
      PurchaseOrder.count(),
      PurchaseOrder.count({ where: { status: "draft" } }),
      PurchaseOrder.count({ where: { status: "sent" } }),
      PurchaseOrder.count({ where: { status: "acknowledged" } }),
      PurchaseOrder.count({ where: { status: "completed" } }),
      PurchaseOrder.count({ where: { status: "cancelled" } }),
      PurchaseOrder.count({ where: { isAutoGenerated: true } }),
      PurchaseOrder.count({ where: { isAutoGenerated: false } }),
      
      // GRNs
      GRN.count(),
      GRN.count({ where: { status: "pending" } }),
      GRN.count({ where: { status: "approved" } }),
      
      // USER ROLE BREAKDOWN
      User.count({ where: { role: "admin" } }),
      User.count({ where: { role: "manager" } }),
      User.count({ where: { role: "warehouse" } }),
      User.count({ where: { role: "supplier" } })
    ]);

    // Filter for low stock using proper reorder logic
    const lowStockLocations = allStockLocations.filter(location => {
      const item = location.item;
      
      // Use only reorder point (it already includes safety stock)
      const itemReorderPoint = item.reorderPoint || 0;
      
      // Use the higher of: location minStock OR item reorder point
      const effectiveMinimum = Math.max(location.minStock || 0, itemReorderPoint);
      
      // Item is low stock if current stock <= effective minimum
      return location.currentStock <= effectiveMinimum;
    });

    // Role-specific data
    let roleSpecificData = {};
    
    if (role === 'supplier') {
      // Find supplier profile
      const supplier = await Supplier.findOne({ where: { userId: req.user.id } });
      if (supplier) {
        const [supplierPOs, supplierSentPOs, supplierAcknowledgedPOs, supplierCompletedPOs] = await Promise.all([
          PurchaseOrder.count({ 
            where: { 
              supplierId: supplier.id,
              status: ['sent', 'acknowledged', 'delay_requested', 'partially_received', 'completed']
            }
          }),
          PurchaseOrder.count({ where: { supplierId: supplier.id, status: 'sent' } }),
          PurchaseOrder.count({ where: { supplierId: supplier.id, status: 'acknowledged' } }),
          PurchaseOrder.count({ where: { supplierId: supplier.id, status: 'completed' } })
        ]);

        roleSpecificData.supplierPOs = {
          total: supplierPOs,
          sent: supplierSentPOs,
          acknowledged: supplierAcknowledgedPOs,
          completed: supplierCompletedPOs
        };
      }
    } else if (role === 'warehouse') {
      // Warehouse-specific data - only acknowledged POs and GRNs
      const [warehouseGRNs, warehouseAcknowledgedPOs] = await Promise.all([
        GRN.count({ where: { receivedById: req.user.id } }),
        PurchaseOrder.count({ where: { status: 'acknowledged' } })
      ]);
      
      roleSpecificData.warehouseGrns = {
        created: warehouseGRNs
      };
      roleSpecificData.warehousePOs = {
        acknowledged: warehouseAcknowledgedPOs
      };
    }

    const endTime = Date.now();
    console.log(`Dashboard query completed in ${endTime - startTime}ms`);

    res.json({
      role,

      counts: {
        users: totalUsers,
        usersByRole: {
          admin: adminUsers,
          manager: managerUsers,
          warehouse: warehouseUsers,
          supplier: supplierUsers
        },
        categories: totalCategories,
        items: totalItems,
        warehouses: totalWarehouses,
        stockLocations: totalStockLocations,
        suppliers: totalSuppliers,

        // Role-based PR/PO data
        ...(role === 'warehouse' ? {
          // Warehouse sees NO PR data and only acknowledged POs
          purchaseOrders: roleSpecificData.warehousePOs?.acknowledged || 0,
          purchaseOrdersByStatus: {
            acknowledged: roleSpecificData.warehousePOs?.acknowledged || 0
          }
        } : {
          // Admin/Manager see full PR/PO data
          purchaseRequests: totalPRs,
          purchaseRequestsByStatus: {
            pending: pendingPRs,
            approved: approvedPRs,
            rejected: rejectedPRs,
            converted_to_po: convertedPRs
          },
          purchaseRequestsByType: {
            auto: autoPRs,
            manual: manualPRs
          },

          purchaseOrders: totalPOs,
          purchaseOrdersByStatus: {
            draft: draftPOs,
            sent: sentPOs,
            acknowledged: acknowledgedPOs,
            completed: completedPOs,
            cancelled: cancelledPOs
          },
          purchaseOrdersByType: {
            auto: autoPOs,
            manual: manualPOs
          }
        }),

        grns: totalGRNs,
        grnsByStatus: {
          pending: pendingGRNs,
          approved: approvedGRNs
        },

        transferOrders: {
          pending: transferOrdersPending,
          approved: transferOrdersApproved,
          rejected: transferOrdersRejected,
          completed: transferOrdersCompleted,
          cancelled: transferOrdersCancelled
        },

        ...roleSpecificData
      },

      lowStockLocations
    });

  } catch (error) {
    console.error("Dashboard error:", error);
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
