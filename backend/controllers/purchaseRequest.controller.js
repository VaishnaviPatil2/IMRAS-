const { PurchaseRequest, Item, Warehouse, User, Category, Supplier } = require('../models');
const AutoPOService = require('../services/autoPoService');

// Get all purchase requests
exports.getAllPurchaseRequests = async (req, res) => {
  try {
    const { status, urgency, isAutoGenerated } = req.query;
    
    const whereClause = {};
    if (status) whereClause.status = status;
    if (urgency) whereClause.urgencyLevel = urgency;
    if (isAutoGenerated !== undefined) whereClause.isAutoGenerated = isAutoGenerated === 'true';

    // Role-based access control
    let accessLevel = 'none';
    if (req.user.role === 'admin' || req.user.role === 'manager') {
      accessLevel = 'full'; // Can view all PRs
    } else if (req.user.role === 'warehouse') {
      accessLevel = 'readonly'; // Can view but not modify
    } else {
      return res.status(403).json({
        success: false,
        message: 'Access denied. Insufficient permissions to view purchase requests.'
      });
    }

    const purchaseRequests = await PurchaseRequest.findAll({
      where: whereClause,
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'requestedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'approvedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: Supplier,
          as: 'preferredSupplier',
          attributes: ['id', 'name', 'email', 'leadTimeDays'],
          required: false
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    res.json({
      success: true,
      data: purchaseRequests,
      count: purchaseRequests.length,
      accessLevel: accessLevel, // Frontend can use this to show/hide buttons
      userRole: req.user.role
    });

  } catch (error) {
    console.error('Error fetching purchase requests:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch purchase requests',
      error: error.message
    });
  }
};

// Create purchase request
exports.createPurchaseRequest = async (req, res) => {
  try {
    console.log('ðŸ“ Creating Purchase Request...');
    console.log('Request body:', req.body);
    console.log('User:', req.user);

    const {
      itemId,
      warehouseId,
      requestedQuantity,
      urgencyLevel,
      reason,
      notes,
      preferredSupplierId
    } = req.body;

    // Validate required fields
    if (!itemId || !warehouseId || !requestedQuantity) {
      console.log('âŒ Missing required fields:', { itemId, warehouseId, requestedQuantity });
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: itemId, warehouseId, and requestedQuantity are required'
      });
    }

    // Validate user
    if (!req.user || !req.user.id) {
      console.log('âŒ No user found in request');
      return res.status(401).json({
        success: false,
        message: 'User authentication required'
      });
    }

    console.log('âœ… Validation passed, creating PR...');

    // Always generate PR number in controller to ensure it's set
    const lastPR = await PurchaseRequest.findOne({
      order: [['id', 'DESC']]
    });
    
    let nextNumber = 1;
    if (lastPR && lastPR.prNumber) {
      const match = lastPR.prNumber.match(/PR(\d+)/);
      if (match) {
        nextNumber = parseInt(match[1]) + 1;
      }
    }
    
    const prNumber = `PR${String(nextNumber).padStart(6, '0')}`;
    console.log('Generated PR Number in controller:', prNumber);

    const purchaseRequest = await PurchaseRequest.create({
      prNumber: prNumber, // Explicitly set PR number
      itemId: parseInt(itemId),
      warehouseId: parseInt(warehouseId),
      requestedQuantity: parseInt(requestedQuantity),
      urgencyLevel: urgencyLevel || 'medium',
      reason: reason || 'manual_request',
      notes,
      requestedById: req.user.id,
      isAutoGenerated: false,
      preferredSupplierId: preferredSupplierId ? parseInt(preferredSupplierId) : null
    });

    console.log('âœ… PR created with ID:', purchaseRequest.id);

    const createdPR = await PurchaseRequest.findByPk(purchaseRequest.id, {
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'requestedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: Supplier,
          as: 'preferredSupplier',
          attributes: ['id', 'name', 'email', 'leadTimeDays'],
          required: false
        }
      ]
    });

    console.log('âœ… PR created successfully:', createdPR.prNumber);

    res.status(201).json({
      success: true,
      message: 'Purchase request created successfully',
      data: createdPR
    });

  } catch (error) {
    console.error('âŒ Error creating purchase request:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    
    res.status(500).json({
      success: false,
      message: 'Failed to create purchase request',
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// Approve/Reject purchase request
exports.updatePurchaseRequestStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { action, notes } = req.body; // action: 'approve' or 'reject'

    const purchaseRequest = await PurchaseRequest.findByPk(id);
    if (!purchaseRequest) {
      return res.status(404).json({
        success: false,
        message: 'Purchase request not found'
      });
    }

    if (purchaseRequest.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'Purchase request is not in pending status'
      });
    }

    const updateData = {
      approvedById: req.user.id,
      approvedAt: new Date(),
      notes: notes || purchaseRequest.notes
    };

    if (action === 'approve') {
      updateData.status = 'approved';
      await purchaseRequest.update(updateData);
      
      // Auto-generate PO for approved PR
      try {
        await AutoPOService.generatePOFromPR(purchaseRequest, req.user.id, true);
      } catch (poError) {
        console.error('Error generating PO:', poError);
        // Don't fail the approval if PO generation fails
      }
      
    } else if (action === 'reject') {
      updateData.status = 'rejected';
      await purchaseRequest.update(updateData);
    } else {
      return res.status(400).json({
        success: false,
        message: 'Invalid action. Use "approve" or "reject"'
      });
    }

    const updatedPR = await PurchaseRequest.findByPk(id, {
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'requestedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'approvedBy',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    res.json({
      success: true,
      message: `Purchase request ${action}d successfully`,
      data: updatedPR
    });

  } catch (error) {
    console.error('Error updating purchase request status:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update purchase request status',
      error: error.message
    });
  }
};

// Trigger automatic low stock check and PO generation
exports.triggerAutoPoGeneration = async (req, res) => {
  try {
    const result = await AutoPOService.checkLowStockAndGeneratePO();
    
    res.json({
      success: true,
      message: 'Auto PO generation completed',
      data: result
    });

  } catch (error) {
    console.error('Error in auto PO generation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to generate automatic POs',
      error: error.message
    });
  }
};

// Create PO from PR (Manager's "Create PO" button)
exports.createPOFromPR = async (req, res) => {
  try {
    const { id } = req.params;
    
    const purchaseRequest = await PurchaseRequest.findByPk(id, {
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        }
      ]
    });

    if (!purchaseRequest) {
      return res.status(404).json({
        success: false,
        message: 'Purchase request not found'
      });
    }

    if (purchaseRequest.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'Purchase request is not in pending status'
      });
    }

    // âœ… FIXED: Only create PO, don't change PR status
    // PR should remain pending until explicitly approved
    
    // Check if suppliers exist before creating PO
    const { Supplier } = require('../models');
    const supplierCount = await Supplier.count();
    if (supplierCount === 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot create PO: No suppliers found. Please add at least one supplier first.',
        action: 'add_supplier'
      });
    }
    
    // Generate PO using AutoPOService (without changing PR status)
    const poResult = await AutoPOService.generatePOFromPR(purchaseRequest, req.user.id, false);

    // âŒ REMOVED: Don't auto-change PR status to converted_to_po
    // The PR should remain pending for explicit approval
    // await purchaseRequest.update({
    //   status: 'converted_to_po'
    // });

    res.json({
      success: true,
      message: 'Purchase order created successfully from PR. PR remains pending for approval.',
      data: {
        purchaseRequest: purchaseRequest,
        purchaseOrder: poResult
      }
    });

  } catch (error) {
    console.error('Error creating PO from PR:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create PO from PR',
      error: error.message
    });
  }
};

// Get low stock summary
exports.getLowStockSummary = async (req, res) => {
  try {
    const summary = await AutoPOService.getLowStockSummary();
    
    res.json({
      success: true,
      data: summary
    });

  } catch (error) {
    console.error('Error getting low stock summary:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get low stock summary',
      error: error.message
    });
  }
};

// Edit purchase request (Manager + Admin override)
exports.editPurchaseRequest = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      itemId,
      warehouseId,
      requestedQuantity,
      urgencyLevel,
      reason,
      notes,
      preferredSupplierId
    } = req.body;

    const purchaseRequest = await PurchaseRequest.findByPk(id);
    if (!purchaseRequest) {
      return res.status(404).json({
        success: false,
        message: 'Purchase request not found'
      });
    }

    // Check if PR can be edited (not converted to PO yet)
    if (purchaseRequest.status === 'converted_to_po') {
      return res.status(400).json({
        success: false,
        message: 'Cannot edit purchase request that has been converted to PO'
      });
    }

    // Log admin override if applicable
    if (req.user.role === 'admin') {
      console.log(`ðŸš¨ Admin Override: ${req.user.name} edited PR ${purchaseRequest.prNumber}`);
    }

    await purchaseRequest.update({
      itemId: itemId || purchaseRequest.itemId,
      warehouseId: warehouseId || purchaseRequest.warehouseId,
      requestedQuantity: requestedQuantity || purchaseRequest.requestedQuantity,
      urgencyLevel: urgencyLevel || purchaseRequest.urgencyLevel,
      reason: reason || purchaseRequest.reason,
      notes: notes || purchaseRequest.notes,
      preferredSupplierId: preferredSupplierId !== undefined ? (preferredSupplierId ? parseInt(preferredSupplierId) : null) : purchaseRequest.preferredSupplierId
    });

    const updatedPR = await PurchaseRequest.findByPk(id, {
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'requestedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: Supplier,
          as: 'preferredSupplier',
          attributes: ['id', 'name', 'email', 'leadTimeDays'],
          required: false
        }
      ]
    });

    res.json({
      success: true,
      message: 'Purchase request updated successfully',
      data: updatedPR
    });

  } catch (error) {
    console.error('Error editing purchase request:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to edit purchase request',
      error: error.message
    });
  }
};

// Delete purchase request (Manager + Admin override)
exports.deletePurchaseRequest = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body; // Reason required for deletion

    const purchaseRequest = await PurchaseRequest.findByPk(id);
    if (!purchaseRequest) {
      return res.status(404).json({
        success: false,
        message: 'Purchase request not found'
      });
    }

    // Check if PR can be deleted (not converted to PO yet)
    if (purchaseRequest.status === 'converted_to_po') {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete purchase request that has been converted to PO'
      });
    }

    // Require reason for deletion (audit trail)
    if (!reason) {
      return res.status(400).json({
        success: false,
        message: 'Reason is required for deleting purchase request'
      });
    }

    // Log admin override if applicable
    if (req.user.role === 'admin') {
      console.log(`ðŸš¨ Admin Override: ${req.user.name} deleted PR ${purchaseRequest.prNumber} - Reason: ${reason}`);
    }

    // Log deletion for audit trail
    console.log(`PR Deletion: ${purchaseRequest.prNumber} by ${req.user.name} - Reason: ${reason}`);

    await purchaseRequest.destroy();

    res.json({
      success: true,
      message: 'Purchase request deleted successfully',
      deletedPR: {
        id: purchaseRequest.id,
        prNumber: purchaseRequest.prNumber,
        deletedBy: req.user.name,
        reason: reason
      }
    });

  } catch (error) {
    console.error('Error deleting purchase request:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete purchase request',
      error: error.message
    });
  }
};