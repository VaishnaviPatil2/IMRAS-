const { PurchaseRequest, Item, Warehouse, User, Category, Supplier, PurchaseOrder } = require('../models');
const AutoPOService = require('../services/autoPoService');

// Get all purchase requests
exports.getAllPurchaseRequests = async (req, res) => {
  try {
    const { status, urgency, isAutoGenerated, reason } = req.query;
    
    const whereClause = {};
    if (status) whereClause.status = status;
    if (urgency) whereClause.urgencyLevel = urgency;
    if (isAutoGenerated !== undefined && isAutoGenerated !== '') whereClause.isAutoGenerated = isAutoGenerated === 'true';
    if (reason) whereClause.reason = reason;

    // Role-based access control
    let accessLevel = 'none';
    if (req.user.role === 'admin' || req.user.role === 'manager') {
      accessLevel = 'full'; // Can view all PRs
    } else if (req.user.role === 'warehouse') {
      accessLevel = 'readonly'; // Can view but not modify
    } else {
      return res.status(403).json({
        success: false,
        message: 'Access denied. Insufficient permissions to view purchase requests.'
      });
    }

    const purchaseRequests = await PurchaseRequest.findAll({
      where: whereClause,
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'requestedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'approvedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: Supplier,
          as: 'preferredSupplier',
          attributes: ['id', 'name', 'email', 'leadTimeDays'],
          required: false
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    res.json({
      success: true,
      data: purchaseRequests,
      count: purchaseRequests.length,
      accessLevel: accessLevel, // Frontend can use this to show/hide buttons
      userRole: req.user.role
    });

  } catch (error) {
    console.error('Error fetching purchase requests:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch purchase requests',
      error: error.message
    });
  }
};

// Create purchase request
exports.createPurchaseRequest = async (req, res) => {
  try {
    console.log('üìù Creating Purchase Request...');
    console.log('Request body:', req.body);
    console.log('User:', req.user);

    const {
      itemId,
      warehouseId,
      requestedQuantity,
      urgencyLevel,
      reason,
      notes,
      preferredSupplierId
    } = req.body;

    // Validate required fields
    if (!itemId || !warehouseId || !requestedQuantity) {
      console.log('‚ùå Missing required fields:', { itemId, warehouseId, requestedQuantity });
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: itemId, warehouseId, and requestedQuantity are required'
      });
    }

    // Validate user
    if (!req.user || !req.user.id) {
      console.log('‚ùå No user found in request');
      return res.status(401).json({
        success: false,
        message: 'User authentication required'
      });
    }

    console.log('‚úÖ Validation passed, creating PR...');

    // ===== BASIC QUANTITY VALIDATION =====
    // Simple validation - just check if quantity is positive
    if (parseInt(requestedQuantity) <= 0) {
      return res.status(400).json({
        success: false,
        message: 'Requested quantity must be greater than zero'
      });
    }
    // ===== END BASIC VALIDATION =====

    // Always generate PR number in controller to ensure it's set
    const lastPR = await PurchaseRequest.findOne({
      order: [['id', 'DESC']]
    });
    
    let nextNumber = 1;
    if (lastPR && lastPR.prNumber) {
      const match = lastPR.prNumber.match(/PR(\d+)/);
      if (match) {
        nextNumber = parseInt(match[1]) + 1;
      }
    }
    
    const prNumber = `PR${String(nextNumber).padStart(6, '0')}`;
    console.log('Generated PR Number in controller:', prNumber);

    const purchaseRequest = await PurchaseRequest.create({
      prNumber: prNumber, // Explicitly set PR number
      itemId: parseInt(itemId),
      warehouseId: parseInt(warehouseId),
      requestedQuantity: parseInt(requestedQuantity),
      urgencyLevel: urgencyLevel || 'medium',
      reason: reason || 'manual_request',
      notes,
      requestedById: req.user.id,
      isAutoGenerated: false,
      preferredSupplierId: preferredSupplierId ? parseInt(preferredSupplierId) : null
    });

    console.log('‚úÖ PR created with ID:', purchaseRequest.id);

    const createdPR = await PurchaseRequest.findByPk(purchaseRequest.id, {
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'requestedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: Supplier,
          as: 'preferredSupplier',
          attributes: ['id', 'name', 'email', 'leadTimeDays'],
          required: false
        }
      ]
    });

    console.log('‚úÖ PR created successfully:', createdPR.prNumber);

    res.status(201).json({
      success: true,
      message: 'Purchase request created successfully',
      data: createdPR
    });

  } catch (error) {
    console.error('‚ùå Error creating purchase request:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    
    res.status(500).json({
      success: false,
      message: 'Failed to create purchase request',
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// Approve/Reject purchase request
exports.updatePurchaseRequestStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { action, notes } = req.body; // action: 'approve' or 'reject'

    const purchaseRequest = await PurchaseRequest.findByPk(id);
    if (!purchaseRequest) {
      return res.status(404).json({
        success: false,
        message: 'Purchase request not found'
      });
    }

    if (purchaseRequest.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'Purchase request is not in pending status'
      });
    }

    const updateData = {
      approvedById: req.user.id,
      approvedAt: new Date(),
      notes: notes || purchaseRequest.notes
    };

    if (action === 'approve') {
      updateData.status = 'approved';
      await purchaseRequest.update(updateData);
      
      // Auto-generate PO for approved PR
      try {
        await AutoPOService.generatePOFromPR(purchaseRequest, req.user.id, true);
      } catch (poError) {
        console.error('Error generating PO:', poError);
        // Don't fail the approval if PO generation fails
      }
      
    } else if (action === 'reject') {
      updateData.status = 'rejected';
      await purchaseRequest.update(updateData);
    } else {
      return res.status(400).json({
        success: false,
        message: 'Invalid action. Use "approve" or "reject"'
      });
    }

    const updatedPR = await PurchaseRequest.findByPk(id, {
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'requestedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'approvedBy',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    res.json({
      success: true,
      message: `Purchase request ${action}d successfully`,
      data: updatedPR
    });

  } catch (error) {
    console.error('Error updating purchase request status:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update purchase request status',
      error: error.message
    });
  }
};

// Trigger automatic low stock check and PR generation
exports.triggerAutoPoGeneration = async (req, res) => {
  try {
    console.log(`üöÄ ${req.user.name} (${req.user.role}) triggered automatic PR generation`);
    
    // Use inline implementation since module exports have issues
    const { StockLocation, Item, Warehouse, Supplier, PurchaseRequest, PurchaseOrder, User } = require('../models');
    
    // Find all active stock locations with their items
    const allStockLocations = await StockLocation.findAll({
      where: { isActive: true },
      include: [
        {
          model: Item,
          as: 'item',
          where: { isActive: true },
          attributes: ['id', 'sku', 'name', 'reorderPoint', 'safetyStock', 'leadTimeDays', 'dailyConsumption', 'unitPrice']
        },
        {
          model: Warehouse,
          as: 'warehouse',
          where: { isActive: true }
        }
      ]
    });

    // Filter for low stock using proper reorder logic
    const lowStockLocations = allStockLocations.filter(location => {
      const item = location.item;
      // Use reorderPoint directly as it already includes safetyStock in scientific formula
      const itemReorderThreshold = item.reorderPoint || 0;
      const effectiveMinimum = Math.max(location.minStock || 0, itemReorderThreshold);
      return location.currentStock <= effectiveMinimum;
    });

    console.log(`üìä Found ${lowStockLocations.length} low stock locations`);

    let prsCreated = 0;
    let prsAutoApproved = 0;
    let prsSkipped = 0;
    let posCreated = 0;
    let errors = [];

    // Process each low stock location
    for (const location of lowStockLocations) {
      try {
        const item = location.item;
        const warehouse = location.warehouse;
        
        console.log(`üîç DEBUG: Auto trigger - Item from location:`, {
          id: item.id,
          name: item.name,
          sku: item.sku,
          unitPrice: item.unitPrice,
          unitPriceType: typeof item.unitPrice,
          allKeys: Object.keys(item.dataValues || item)
        });
        
        // Check if PR already exists
        const existingPR = await PurchaseRequest.findOne({
          where: {
            itemId: item.id,
            warehouseId: warehouse.id,
            status: ['pending', 'approved', 'converted_to_po'],
            isAutoGenerated: true
          }
        });

        if (existingPR) {
          console.log(`‚è≠Ô∏è Skipping - PR already exists for ${item.name} at ${warehouse.name}`);
          prsSkipped++;
          continue;
        }

        // Find admin user
        const systemUser = await User.findOne({
          where: { role: 'admin' },
          order: [['createdAt', 'ASC']]
        });

        if (!systemUser) {
          throw new Error('No admin user found');
        }

        // Min-Max System Required Quantity Calculation (Project Standard)
        const currentStock = location.currentStock || 0;
        const minStock = location.minStock || 0;  // This equals item.reorderPoint
        const maxStock = location.maxStock || 0;  // This equals item.reorderPoint * 3
        
        // Min-Max Logic: When stock hits minimum, order up to maximum
        // This is the standard approach used in your project's seedData
        const requiredQuantity = Math.max(1, maxStock - currentStock);
        
        console.log(`[MIN-MAX PR] Item: ${item.name}, Current: ${currentStock}, Min: ${minStock}, Max: ${maxStock}, Required: ${requiredQuantity}`);

        // Determine urgency based on industry standard logic
        const effectiveMinimum = Math.max(location.minStock || 0, item.reorderPoint || 0);
        
        let urgencyLevel = 'medium';
        if (location.currentStock === 0) {
          urgencyLevel = 'urgent';  // üî¥ OUT OF STOCK
        } else if (location.currentStock <= (effectiveMinimum * 0.5)) {
          urgencyLevel = 'high';    // üü° VERY LOW STOCK
        }

        // Create PR
        const pr = await PurchaseRequest.create({
          itemId: item.id,
          warehouseId: warehouse.id,
          requestedQuantity: requiredQuantity,
          urgencyLevel: urgencyLevel,
          reason: urgencyLevel === 'urgent' ? 'out_of_stock' : 'low_stock',
          status: 'pending',
          notes: `${urgencyLevel === 'urgent' ? 'üö® URGENT' : urgencyLevel === 'high' ? 'üü° HIGH' : 'üü® MEDIUM'} Auto-generated PR - Current: ${location.currentStock}, Min: ${location.minStock}, Max: ${location.maxStock}`,
          requestedById: systemUser.id,
          isAutoGenerated: true
        });

        console.log(`‚úÖ Created PR ${pr.prNumber} for ${item.name} (${urgencyLevel.toUpperCase()})`);
        prsCreated++;

        // Apply industry standard logic based on priority
        if (urgencyLevel === 'urgent' || urgencyLevel === 'high') {
          // Auto approve for URGENT and HIGH priority
          await pr.update({
            status: 'approved',
            approvedById: systemUser.id,
            approvedAt: new Date()
          });
          console.log(`üöÄ Auto-approved ${urgencyLevel.toUpperCase()} PR ${pr.prNumber}`);
          prsAutoApproved++;

          // Create PO for approved PR
          try {
            // Find supplier
            const supplier = await Supplier.findOne({
              order: [['leadTimeDays', 'ASC']]
            });

            if (supplier) {
              // Fetch complete item details to ensure unitPrice is available
              const fullItem = await Item.findByPk(item.id, {
                attributes: ['id', 'sku', 'name', 'unitPrice', 'reorderPoint', 'safetyStock']
              });
              
              if (!fullItem) {
                throw new Error(`Item not found: ${item.id}`);
              }
              
              console.log(`üí∞ DEBUG: Full item fetch for unit price:`, {
                itemName: fullItem.name,
                itemUnitPrice: fullItem.unitPrice,
                itemUnitPriceType: typeof fullItem.unitPrice,
                originalItemUnitPrice: item.unitPrice,
                originalItemUnitPriceType: typeof item.unitPrice
              });
              
              if (!fullItem.unitPrice) {
                throw new Error(`Unit price not set for item: ${fullItem.name} (${fullItem.sku}). Please set unit price in Item Catalog.`);
              }
              
              const unitPrice = fullItem.unitPrice;
              console.log(`‚úÖ Using actual unit price: ${unitPrice} for ${fullItem.name}`);
              
              const totalAmount = pr.requestedQuantity * unitPrice;
              
              // Generate PO number
              const poCount = await PurchaseOrder.count();
              const poNumber = `PO${String(poCount + 1).padStart(6, '0')}`;

              // Calculate delivery date
              const expectedDeliveryDate = new Date();
              expectedDeliveryDate.setDate(expectedDeliveryDate.getDate() + (supplier.leadTimeDays || 7));

              // Create PO
              const po = await PurchaseOrder.create({
                poNumber: poNumber,
                prId: pr.id,
                supplierId: supplier.id,
                itemId: pr.itemId,
                warehouseId: pr.warehouseId,
                orderedQuantity: pr.requestedQuantity,
                unitPrice: unitPrice,
                totalAmount: totalAmount,
                priority: pr.urgencyLevel,
                status: 'draft',
                expectedDeliveryDate: expectedDeliveryDate,
                notes: `Auto-generated PO from PR ${pr.prNumber} - Priority: ${pr.urgencyLevel.toUpperCase()}`,
                createdById: systemUser.id,
                isAutoGenerated: true
              });

              // Update PR status
              await pr.update({ status: 'converted_to_po' });

              console.log(`‚úÖ Created PO ${po.poNumber} from PR ${pr.prNumber}`);
              posCreated++;

              // For URGENT: Auto send to supplier (bypass admin)
              if (urgencyLevel === 'urgent') {
                await po.update({
                  status: 'sent',
                  sentAt: new Date()
                });
                console.log(`üìß URGENT PO ${po.poNumber} sent directly to supplier (BYPASSED ADMIN)`);
              } else {
                console.log(`üü° HIGH PO ${po.poNumber} created - Awaiting admin approval`);
              }
            }
          } catch (poError) {
            console.error('Error creating PO:', poError.message);
            errors.push(`PO creation failed for PR ${pr.prNumber}: ${poError.message}`);
          }
        } else {
          // MEDIUM: PR stays pending for manual approval
          console.log(`‚è≥ MEDIUM PR ${pr.prNumber} created - Awaiting manager approval`);
        }

      } catch (error) {
        console.error(`‚ùå Error processing location ${location.id}:`, error.message);
        errors.push(`Location ${location.id}: ${error.message}`);
      }
    }

    const result = {
      success: true,
      processedLocations: lowStockLocations.length,
      summary: { 
        prsCreated: prsCreated, 
        prsAutoApproved: prsAutoApproved,
        prsSkipped: prsSkipped,
        posCreated: posCreated,
        lowStockLocationsFound: lowStockLocations.length,
        totalLocationsChecked: allStockLocations.length,
        errors: errors
      },
      message: `Generated ${prsCreated} PRs and ${posCreated} POs`
    };
    
    res.json({
      success: true,
      message: 'Automatic PR generation completed successfully',
      data: result
    });

  } catch (error) {
    console.error('Error in automatic PR generation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to generate automatic PRs',
      error: error.message
    });
  }
};

// Create PO from PR (Manager's "Create PO" button)
// Create PO from PR (Manager's "Create PO" button)
exports.createPOFromPR = async (req, res) => {
  try {
    const { id } = req.params;
    
    const purchaseRequest = await PurchaseRequest.findByPk(id, {
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        }
      ]
    });

    if (!purchaseRequest) {
      return res.status(404).json({
        success: false,
        message: 'Purchase request not found'
      });
    }

    if (purchaseRequest.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'Purchase request is not in pending status'
      });
    }

    // ‚úÖ CHECK: Prevent duplicate PO creation from same PR
    const existingPO = await PurchaseOrder.findOne({
      where: { prId: id }
    });

    if (existingPO) {
      return res.status(400).json({
        success: false,
        message: `Purchase order already exists for this PR. PO Number: ${existingPO.poNumber}`,
        data: {
          existingPO: {
            id: existingPO.id,
            poNumber: existingPO.poNumber,
            status: existingPO.status,
            totalAmount: existingPO.totalAmount
          }
        }
      });
    }

    // Check if suppliers exist before creating PO
    const supplierCount = await Supplier.count();
    if (supplierCount === 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot create PO: No suppliers found. Please add at least one supplier first.',
        action: 'add_supplier'
      });
    }
    
    // Create PO directly without using AutoPOService (temporary fix)
    const supplier = await Supplier.findOne({
      order: [['leadTimeDays', 'ASC']]
    });

    if (!supplier) {
      return res.status(400).json({
        success: false,
        message: 'No active suppliers found'
      });
    }

    // Get item details - Fetch complete item to ensure unitPrice is available
    const fullItem = await Item.findByPk(purchaseRequest.itemId, {
      attributes: ['id', 'sku', 'name', 'unitPrice', 'reorderPoint', 'safetyStock']
    });
    
    if (!fullItem) {
      return res.status(400).json({
        success: false,
        message: 'Item not found'
      });
    }

    if (!fullItem.unitPrice) {
      return res.status(400).json({
        success: false,
        message: `Unit price not set for item: ${fullItem.name} (${fullItem.sku}). Please set unit price in Item Catalog.`
      });
    }

    const unitPrice = fullItem.unitPrice;
    console.log(`üí∞ Manual PO: Using actual unit price ${unitPrice} for ${fullItem.name}`);
    
    const totalAmount = purchaseRequest.requestedQuantity * unitPrice;
    
    // Generate PO number
    const poCount = await PurchaseOrder.count();
    const poNumber = `PO${String(poCount + 1).padStart(6, '0')}`;

    // Calculate delivery date
    const expectedDeliveryDate = new Date();
    expectedDeliveryDate.setDate(expectedDeliveryDate.getDate() + (supplier.leadTimeDays || 7));

    // Create PO
    const po = await PurchaseOrder.create({
      poNumber: poNumber,
      prId: purchaseRequest.id,
      supplierId: supplier.id,
      itemId: purchaseRequest.itemId,
      warehouseId: purchaseRequest.warehouseId,
      orderedQuantity: purchaseRequest.requestedQuantity,
      unitPrice: unitPrice,
      totalAmount: totalAmount,
      priority: purchaseRequest.urgencyLevel,
      status: 'draft',
      expectedDeliveryDate: expectedDeliveryDate,
      notes: `Manual PO created from PR ${purchaseRequest.prNumber} - Priority: ${purchaseRequest.urgencyLevel.toUpperCase()}`,
      createdById: req.user.id,
      isAutoGenerated: false // This is a manual PO creation
    });

    console.log(`‚úÖ Manual PO ${po.poNumber} created from PR ${purchaseRequest.prNumber} by ${req.user.name}`);

    // Load the complete PO with relations for response
    const completePO = await PurchaseOrder.findByPk(po.id, {
      include: [
        {
          model: PurchaseRequest,
          as: 'purchaseRequest',
          attributes: ['id', 'prNumber', 'urgencyLevel', 'reason']
        },
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: Supplier,
          as: 'supplier'
        },
        {
          model: User,
          as: 'createdBy',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    res.json({
      success: true,
      message: 'Purchase order created successfully from PR. PR remains pending for approval.',
      data: {
        purchaseRequest: purchaseRequest,
        purchaseOrder: completePO
      }
    });

  } catch (error) {
    console.error('Error creating PO from PR:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create PO from PR',
      error: error.message
    });
  }
};

// Get low stock summary
exports.getLowStockSummary = async (req, res) => {
  try {
    const summary = await AutoPOService.getLowStockSummary();
    
    res.json({
      success: true,
      data: summary
    });

  } catch (error) {
    console.error('Error getting low stock summary:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get low stock summary',
      error: error.message
    });
  }
};

// Edit purchase request (Manager + Admin override)
exports.editPurchaseRequest = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      itemId,
      warehouseId,
      requestedQuantity,
      urgencyLevel,
      reason,
      notes,
      preferredSupplierId
    } = req.body;

    const purchaseRequest = await PurchaseRequest.findByPk(id);
    if (!purchaseRequest) {
      return res.status(404).json({
        success: false,
        message: 'Purchase request not found'
      });
    }

    // Check if PR can be edited (not converted to PO yet)
    if (purchaseRequest.status === 'converted_to_po') {
      return res.status(400).json({
        success: false,
        message: 'Cannot edit purchase request that has been converted to PO'
      });
    }

    // Log admin override if applicable
    if (req.user.role === 'admin') {
      console.log(`üö® Admin Override: ${req.user.name} edited PR ${purchaseRequest.prNumber}`);
    }

    await purchaseRequest.update({
      itemId: itemId || purchaseRequest.itemId,
      warehouseId: warehouseId || purchaseRequest.warehouseId,
      requestedQuantity: requestedQuantity || purchaseRequest.requestedQuantity,
      urgencyLevel: urgencyLevel || purchaseRequest.urgencyLevel,
      reason: reason || purchaseRequest.reason,
      notes: notes || purchaseRequest.notes,
      preferredSupplierId: preferredSupplierId !== undefined ? (preferredSupplierId ? parseInt(preferredSupplierId) : null) : purchaseRequest.preferredSupplierId
    });

    const updatedPR = await PurchaseRequest.findByPk(id, {
      include: [
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'requestedBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: Supplier,
          as: 'preferredSupplier',
          attributes: ['id', 'name', 'email', 'leadTimeDays'],
          required: false
        }
      ]
    });

    res.json({
      success: true,
      message: 'Purchase request updated successfully',
      data: updatedPR
    });

  } catch (error) {
    console.error('Error editing purchase request:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to edit purchase request',
      error: error.message
    });
  }
};

// Delete purchase request (Manager + Admin override)
exports.deletePurchaseRequest = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body; // Reason required for deletion

    const purchaseRequest = await PurchaseRequest.findByPk(id);
    if (!purchaseRequest) {
      return res.status(404).json({
        success: false,
        message: 'Purchase request not found'
      });
    }

    // Check if PR can be deleted (not converted to PO yet)
    if (purchaseRequest.status === 'converted_to_po') {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete purchase request that has been converted to PO'
      });
    }

    // Require reason for deletion (audit trail)
    if (!reason) {
      return res.status(400).json({
        success: false,
        message: 'Reason is required for deleting purchase request'
      });
    }

    // Log admin override if applicable
    if (req.user.role === 'admin') {
      console.log(`üö® Admin Override: ${req.user.name} deleted PR ${purchaseRequest.prNumber} - Reason: ${reason}`);
    }

    // Log deletion for audit trail
    console.log(`PR Deletion: ${purchaseRequest.prNumber} by ${req.user.name} - Reason: ${reason}`);

    await purchaseRequest.destroy();

    res.json({
      success: true,
      message: 'Purchase request deleted successfully',
      deletedPR: {
        id: purchaseRequest.id,
        prNumber: purchaseRequest.prNumber,
        deletedBy: req.user.name,
        reason: reason
      }
    });

  } catch (error) {
    console.error('Error deleting purchase request:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete purchase request',
      error: error.message
    });
  }
};

// Validate quantity before PR creation (separate endpoint for real-time validation)
exports.validateQuantity = async (req, res) => {
  try {
    const { itemId, warehouseId, requestedQuantity, urgencyLevel } = req.body;

    if (!itemId || !warehouseId || !requestedQuantity) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: itemId, warehouseId, and requestedQuantity are required'
      });
    }

    const { StockLocation } = require('../models');
    
    // Get stock location for this item and warehouse
    const stockLocation = await StockLocation.findOne({
      where: {
        itemId: parseInt(itemId),
        warehouseId: parseInt(warehouseId),
        isActive: true
      },
      include: [
        {
          model: Item,
          as: 'item',
          attributes: ['id', 'name', 'sku', 'reorderPoint', 'safetyStock', 'dailyConsumption', 'leadTimeDays']
        }
      ]
    });

    if (!stockLocation) {
      return res.json({
        success: true,
        message: 'No stock location found - basic validation only',
        validation: {
          hasStockData: false,
          isValid: parseInt(requestedQuantity) > 0,
          errors: parseInt(requestedQuantity) <= 0 ? ['Quantity must be greater than zero'] : [],
          warnings: [],
          suggestions: ['No stock data available for detailed validation']
        }
      });
    }

    const currentStock = stockLocation.currentStock || 0;
    const minStock = stockLocation.minStock || 0;
    const maxStock = stockLocation.maxStock || 0;
    const item = stockLocation.item;
    
    // Calculate effective minimum using Min-Max logic
    const itemReorderThreshold = item.reorderPoint || 0;
    const effectiveMinimum = Math.max(minStock, itemReorderThreshold);
    
    // Calculate suggested quantity using Min-Max system
    const suggestedQuantity = maxStock - currentStock;
    const requestedQty = parseInt(requestedQuantity);
    
    // Validation logic (same as in create function)
    const validationWarnings = [];
    const validationErrors = [];
    const suggestions = [];

    // HARD ERRORS
    if (requestedQty <= 0) {
      validationErrors.push('Requested quantity must be greater than zero.');
    }

    if ((currentStock + requestedQty) > (maxStock * 1.5)) {
      validationErrors.push(`Total stock after delivery (${currentStock + requestedQty}) would significantly exceed warehouse capacity (${maxStock}). Maximum recommended: ${Math.max(0, Math.floor(maxStock * 1.5) - currentStock)} units.`);
    }

    // SOFT WARNINGS
    if (requestedQty > (suggestedQuantity * 3) && suggestedQuantity > 0) {
      validationWarnings.push(`Requested quantity (${requestedQty}) is much higher than calculated need (${suggestedQuantity} units). This may lead to overstocking.`);
    }

    if (urgencyLevel === 'urgent' && currentStock === 0 && requestedQty < (effectiveMinimum * 0.5)) {
      validationWarnings.push(`For urgent requests with zero stock, consider ordering more than ${requestedQty} units. Minimum threshold is ${effectiveMinimum} units.`);
    }

    if (requestedQty < 5 && suggestedQuantity > 20) {
      validationWarnings.push(`Very small quantity (${requestedQty}) requested. Consider ordering ${Math.min(suggestedQuantity, 50)} units to reduce frequent reorders.`);
    }

    // HELPFUL SUGGESTIONS
    if (suggestedQuantity > 0) {
      suggestions.push(`System suggests ${suggestedQuantity} units based on Min-Max calculation (Max: ${maxStock} - Current: ${currentStock}).`);
    }

    if (currentStock <= effectiveMinimum) {
      suggestions.push(`Stock is below reorder point (${effectiveMinimum}). Consider urgent priority.`);
    }

    res.json({
      success: true,
      message: 'Quantity validation completed',
      validation: {
        hasStockData: true,
        isValid: validationErrors.length === 0,
        errors: validationErrors,
        warnings: validationWarnings,
        suggestions: suggestions,
        stockAnalysis: {
          currentStock,
          minStock,
          maxStock,
          effectiveMinimum,
          suggestedQuantity,
          stockStatus: currentStock <= effectiveMinimum ? 'low_stock' : 'sufficient'
        }
      }
    });

  } catch (error) {
    console.error('Quantity validation error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to validate quantity',
      error: error.message
    });
  }
};