const { PurchaseOrder, PurchaseRequest, Item, Warehouse, Supplier, User, Category } = require('../models');
const sendEmail = require('../utils/sendEmail');

// Get all purchase orders (Admin/Manager view)
exports.getAllPurchaseOrders = async (req, res) => {
  try {
    const { status, supplierId, type } = req.query;
    
    const whereClause = {};
    if (status) whereClause.status = status;
    if (supplierId) whereClause.supplierId = supplierId;
    
    // Handle type filter
    if (type) {
      if (type === 'auto') {
        whereClause.isAutoGenerated = true;
      } else if (type === 'manual') {
        whereClause.isAutoGenerated = false;
      }
    }

    // Role-based access control
    let accessLevel = 'none';
    if (req.user.role === 'admin') {
      accessLevel = 'full'; // Can view all, approve, cancel, edit
    } else if (req.user.role === 'manager') {
      accessLevel = 'view'; // Can view all, monitor, but not approve
    } else if (req.user.role === 'warehouse') {
      // âœ… WAREHOUSE RESTRICTION: Only see ACKNOWLEDGED POs (exclude completed and rejected)
      accessLevel = 'limited';
      // Warehouse can only see POs that are acknowledged (ready for GRN creation)
      // Exclude completed and rejected POs
      whereClause.status = 'acknowledged';
    } else {
      return res.status(403).json({
        success: false,
        message: 'Access denied. Insufficient permissions to view purchase orders.'
      });
    }

    const purchaseOrders = await PurchaseOrder.findAll({
      where: whereClause,
      include: [
        {
          model: PurchaseRequest,
          as: 'purchaseRequest',
          attributes: ['id', 'prNumber', 'urgencyLevel', 'reason']
        },
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: Supplier,
          as: 'supplier'
        },
        {
          model: User,
          as: 'createdBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'approvedBy',
          attributes: ['id', 'name', 'email']
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    res.json({
      success: true,
      data: purchaseOrders,
      count: purchaseOrders.length,
      accessLevel: accessLevel, // Frontend can use this to show/hide buttons
      userRole: req.user.role
    });

  } catch (error) {
    console.error('Error fetching purchase orders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch purchase orders',
      error: error.message
    });
  }
};

// Get supplier's purchase orders (Supplier view)
exports.getSupplierPurchaseOrders = async (req, res) => {
  try {
    const { status } = req.query;
    
    // Find supplier by user ID
    const supplier = await Supplier.findOne({
      where: { userId: req.user.id }
    });

    if (!supplier) {
      return res.status(404).json({
        success: false,
        message: 'Supplier profile not found'
      });
    }

    // âœ… FIXED: Suppliers should only see POs that are SENT to them
    // Draft POs should NOT be visible to suppliers until approved and sent
    const whereClause = { 
      supplierId: supplier.id,
      status: ['sent', 'acknowledged', 'partially_received', 'completed'] // Only POs that suppliers can interact with
    };
    
    // Allow additional status filtering if provided, but still restrict to visible statuses
    if (status && ['sent', 'acknowledged', 'partially_received', 'completed'].includes(status)) {
      whereClause.status = status;
    }

    const purchaseOrders = await PurchaseOrder.findAll({
      where: whereClause,
      include: [
        {
          model: PurchaseRequest,
          as: 'purchaseRequest',
          attributes: ['id', 'prNumber', 'urgencyLevel', 'reason']
        },
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'createdBy',
          attributes: ['id', 'name', 'email']
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    res.json({
      success: true,
      data: purchaseOrders,
      count: purchaseOrders.length,
      supplier: {
        id: supplier.id,
        name: supplier.name,
        email: supplier.email
      },
      message: `Showing ${purchaseOrders.length} POs sent to ${supplier.name}`
    });

  } catch (error) {
    console.error('Error fetching supplier purchase orders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch purchase orders',
      error: error.message
    });
  }
};

// Supplier responds to PO (Accept/Reject/Request Delay)
exports.respondToPurchaseOrder = async (req, res) => {
  try {
    const { id } = req.params;
    const { action, notes, proposedDeliveryDate } = req.body;
    
    // Find supplier by user ID
    const supplier = await Supplier.findOne({
      where: { userId: req.user.id }
    });

    if (!supplier) {
      return res.status(404).json({
        success: false,
        message: 'Supplier profile not found'
      });
    }

    // Find PO and verify it belongs to this supplier
    const purchaseOrder = await PurchaseOrder.findOne({
      where: { 
        id: id,
        supplierId: supplier.id 
      },
      include: [
        {
          model: Item,
          as: 'item'
        },
        {
          model: Warehouse,
          as: 'warehouse'
        }
      ]
    });

    if (!purchaseOrder) {
      return res.status(404).json({
        success: false,
        message: 'Purchase order not found or access denied'
      });
    }

    // Check if PO is in valid status for response (suppliers can only respond to SENT POs)
    if (!['sent'].includes(purchaseOrder.status)) {
      return res.status(400).json({
        success: false,
        message: 'Purchase order is not available for response. Only sent POs can be responded to.'
      });
    }

    let updateData = {
      notes: notes || purchaseOrder.notes
    };

    let emailSubject = '';
    let emailContent = '';

    switch (action) {
      case 'accept':
        updateData.status = 'acknowledged';
        // âœ… FIXED: Don't set actualDeliveryDate on accept - only update expectedDeliveryDate if supplier proposes a different date
        if (proposedDeliveryDate) {
          updateData.expectedDeliveryDate = proposedDeliveryDate;
        }
        emailSubject = `PO ${purchaseOrder.poNumber} - ACCEPTED`;
        emailContent = `
          Purchase Order ${purchaseOrder.poNumber} has been ACCEPTED by ${supplier.name}.
          
          Order Details:
          - Item: ${purchaseOrder.item.name}
          - Quantity: ${purchaseOrder.orderedQuantity}
          - Expected Delivery: ${proposedDeliveryDate || purchaseOrder.expectedDeliveryDate}
          
          Supplier Notes: ${notes || 'None'}
        `;
        break;

      case 'reject':
        updateData.status = 'cancelled';
        emailSubject = `PO ${purchaseOrder.poNumber} - REJECTED`;
        emailContent = `
          Purchase Order ${purchaseOrder.poNumber} has been REJECTED by ${supplier.name}.
          
          Order Details:
          - Item: ${purchaseOrder.item.name}
          - Quantity: ${purchaseOrder.orderedQuantity}
          
          Rejection Reason: ${notes || 'No reason provided'}
        `;
        break;

      case 'delay':
        if (!proposedDeliveryDate) {
          return res.status(400).json({
            success: false,
            message: 'Proposed delivery date is required for delay requests'
          });
        }
        // âœ… FIXED: Delay requests need approval - don't auto-update delivery date
        updateData.status = 'delay_requested';
        updateData.proposedDeliveryDate = proposedDeliveryDate; // Store proposed date separately
        // Keep original expectedDeliveryDate until approved
        emailSubject = `PO ${purchaseOrder.poNumber} - DELAY REQUEST (APPROVAL REQUIRED)`;
        emailContent = `
          Purchase Order ${purchaseOrder.poNumber} delivery delay requested by ${supplier.name}.
          
          âš ï¸ APPROVAL REQUIRED by Inventory Manager or Admin
          
          Order Details:
          - Item: ${purchaseOrder.item.name}
          - Quantity: ${purchaseOrder.orderedQuantity}
          - Original Delivery: ${purchaseOrder.expectedDeliveryDate}
          - Proposed Delivery: ${proposedDeliveryDate}
          
          Delay Reason: ${notes || 'No reason provided'}
          
          Please log in to approve/reject this delay request.
        `;
        break;

      default:
        return res.status(400).json({
          success: false,
          message: 'Invalid action. Use "accept", "reject", or "delay"'
        });
    }

    // Update PO
    await purchaseOrder.update(updateData);

    // Send email notification to admin/procurement team
    try {
      await sendEmail(
        process.env.EMAIL_USER, // Send to system admin
        emailSubject,
        emailContent
      );
    } catch (emailError) {
      console.error('Failed to send notification email:', emailError);
      // Don't fail the request if email fails
    }

    // Get updated PO with all relations
    const updatedPO = await PurchaseOrder.findByPk(id, {
      include: [
        {
          model: PurchaseRequest,
          as: 'purchaseRequest',
          attributes: ['id', 'prNumber', 'urgencyLevel']
        },
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: User,
          as: 'createdBy',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    res.json({
      success: true,
      message: `Purchase order ${action}ed successfully`,
      data: updatedPO
    });

  } catch (error) {
    console.error('Error responding to purchase order:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to respond to purchase order',
      error: error.message
    });
  }
};

// Get single PO details
exports.getPurchaseOrderById = async (req, res) => {
  try {
    const { id } = req.params;
    
    let whereClause = { id };
    
    // If supplier, restrict to their POs only
    if (req.user.role === 'supplier') {
      const supplier = await Supplier.findOne({
        where: { userId: req.user.id }
      });
      
      if (!supplier) {
        return res.status(404).json({
          success: false,
          message: 'Supplier profile not found'
        });
      }
      
      whereClause.supplierId = supplier.id;
    }

    const purchaseOrder = await PurchaseOrder.findOne({
      where: whereClause,
      include: [
        {
          model: PurchaseRequest,
          as: 'purchaseRequest',
          attributes: ['id', 'prNumber', 'urgencyLevel', 'reason']
        },
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: Supplier,
          as: 'supplier'
        },
        {
          model: User,
          as: 'createdBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'approvedBy',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    if (!purchaseOrder) {
      return res.status(404).json({
        success: false,
        message: 'Purchase order not found'
      });
    }

    res.json({
      success: true,
      data: purchaseOrder
    });

  } catch (error) {
    console.error('Error fetching purchase order:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch purchase order',
      error: error.message
    });
  }
};

// Admin approves/rejects PO
exports.approvePurchaseOrder = async (req, res) => {
  try {
    const { id } = req.params;
    const { action, notes } = req.body; // action: 'approve' or 'reject'

    const purchaseOrder = await PurchaseOrder.findByPk(id, {
      include: [
        {
          model: Supplier,
          as: 'supplier'
        },
        {
          model: Item,
          as: 'item'
        }
      ]
    });

    if (!purchaseOrder) {
      return res.status(404).json({
        success: false,
        message: 'Purchase order not found'
      });
    }

    if (purchaseOrder.status !== 'draft') {
      return res.status(400).json({
        success: false,
        message: 'Purchase order is not in draft status'
      });
    }

    const updateData = {
      approvedById: req.user.id,
      approvedAt: new Date(),
      notes: notes || purchaseOrder.notes
    };

    if (action === 'approve') {
      updateData.status = 'sent';
      updateData.sentAt = new Date();
      
      // Auto-send email to supplier
      try {
        const sendEmail = require('../utils/sendEmail');
        await sendEmail(
          purchaseOrder.supplier.email,
          `New Purchase Order ${purchaseOrder.poNumber}`,
          `
          You have received a new purchase order.
          
          PO Number: ${purchaseOrder.poNumber}
          Item: ${purchaseOrder.item.name}
          Quantity: ${purchaseOrder.orderedQuantity}
          Total Amount: ${purchaseOrder.totalAmount}
          
          Please log in to your supplier portal to respond:
          ${process.env.FRONTEND_URL}/supplier-dashboard
          `
        );
      } catch (emailError) {
        console.error('Failed to send PO email:', emailError);
        // Don't fail the approval if email fails
      }
      
    } else if (action === 'reject') {
      updateData.status = 'cancelled';
    } else {
      return res.status(400).json({
        success: false,
        message: 'Invalid action. Use "approve" or "reject"'
      });
    }

    await purchaseOrder.update(updateData);

    const updatedPO = await PurchaseOrder.findByPk(id, {
      include: [
        {
          model: PurchaseRequest,
          as: 'purchaseRequest',
          attributes: ['id', 'prNumber', 'urgencyLevel']
        },
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: Supplier,
          as: 'supplier'
        },
        {
          model: User,
          as: 'createdBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'approvedBy',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    res.json({
      success: true,
      message: `Purchase order ${action}d successfully${action === 'approve' ? ' and sent to supplier' : ''}`,
      data: updatedPO
    });

  } catch (error) {
    console.error('Error approving purchase order:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to approve purchase order',
      error: error.message
    });
  }
};
// Edit purchase order (Admin only - before sent)
exports.editPurchaseOrder = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      orderedQuantity,
      unitPrice,
      expectedDeliveryDate,
      notes
    } = req.body;

    const purchaseOrder = await PurchaseOrder.findByPk(id);
    if (!purchaseOrder) {
      return res.status(404).json({
        success: false,
        message: 'Purchase order not found'
      });
    }

    // Check if PO can be edited (not sent yet)
    if (purchaseOrder.status !== 'draft') {
      return res.status(400).json({
        success: false,
        message: 'Cannot edit purchase order that has been sent to supplier'
      });
    }

    // Log admin action
    console.log(`ðŸ”§ Admin Edit: ${req.user.name} edited PO ${purchaseOrder.poNumber}`);

    // Calculate new total amount if quantity or price changed
    const newOrderedQuantity = orderedQuantity || purchaseOrder.orderedQuantity;
    const newUnitPrice = unitPrice || purchaseOrder.unitPrice;
    const newTotalAmount = newOrderedQuantity * newUnitPrice;

    await purchaseOrder.update({
      orderedQuantity: newOrderedQuantity,
      unitPrice: newUnitPrice,
      totalAmount: newTotalAmount,
      expectedDeliveryDate: expectedDeliveryDate || purchaseOrder.expectedDeliveryDate,
      notes: notes || purchaseOrder.notes
    });

    const updatedPO = await PurchaseOrder.findByPk(id, {
      include: [
        {
          model: PurchaseRequest,
          as: 'purchaseRequest',
          attributes: ['id', 'prNumber', 'urgencyLevel']
        },
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: Supplier,
          as: 'supplier'
        },
        {
          model: User,
          as: 'createdBy',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    res.json({
      success: true,
      message: 'Purchase order updated successfully',
      data: updatedPO
    });

  } catch (error) {
    console.error('Error editing purchase order:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to edit purchase order',
      error: error.message
    });
  }
};

// Admin/Manager approves delay request
exports.approveDelayRequest = async (req, res) => {
  try {
    const { id } = req.params;
    const { action, notes } = req.body; // action: 'approve' or 'reject'

    // Only admin or manager can approve delay requests
    if (!['admin', 'manager'].includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Only admin or inventory manager can approve delay requests'
      });
    }

    const purchaseOrder = await PurchaseOrder.findByPk(id, {
      include: [
        { model: Supplier, as: 'supplier' },
        { model: Item, as: 'item' },
        { model: User, as: 'createdBy', attributes: ['id', 'name', 'email'] }
      ]
    });

    if (!purchaseOrder) {
      return res.status(404).json({
        success: false,
        message: 'Purchase order not found'
      });
    }

    if (purchaseOrder.status !== 'delay_requested') {
      return res.status(400).json({
        success: false,
        message: 'Purchase order is not awaiting delay approval'
      });
    }

    const updateData = {
      approvedById: req.user.id,
      approvedAt: new Date(),
      notes: `${purchaseOrder.notes || ''}\n\nDelay ${action}d by ${req.user.name}: ${notes || 'No additional notes'}`
    };

    let emailSubject = '';
    let emailContent = '';

    if (action === 'approve') {
      // Approve delay - update delivery date
      updateData.status = 'acknowledged';
      updateData.expectedDeliveryDate = purchaseOrder.proposedDeliveryDate;
      updateData.proposedDeliveryDate = null; // Clear proposed date
      
      emailSubject = `PO ${purchaseOrder.poNumber} - DELAY APPROVED`;
      emailContent = `
        Your delay request for Purchase Order ${purchaseOrder.poNumber} has been APPROVED.
        
        New Delivery Date: ${purchaseOrder.proposedDeliveryDate}
        Approved by: ${req.user.name} (${req.user.role})
        
        Order Details:
        - Item: ${purchaseOrder.item.name}
        - Quantity: ${purchaseOrder.orderedQuantity}
        
        Please proceed with the new delivery schedule.
      `;
    } else if (action === 'reject') {
      // Reject delay - keep original date
      updateData.status = 'acknowledged';
      updateData.proposedDeliveryDate = null; // Clear proposed date
      
      emailSubject = `PO ${purchaseOrder.poNumber} - DELAY REJECTED`;
      emailContent = `
        Your delay request for Purchase Order ${purchaseOrder.poNumber} has been REJECTED.
        
        Original Delivery Date: ${purchaseOrder.expectedDeliveryDate} (unchanged)
        Rejected by: ${req.user.name} (${req.user.role})
        Reason: ${notes || 'No reason provided'}
        
        Please maintain the original delivery schedule.
      `;
    } else {
      return res.status(400).json({
        success: false,
        message: 'Invalid action. Use "approve" or "reject"'
      });
    }

    await purchaseOrder.update(updateData);

    // Send email to supplier
    try {
      await sendEmail(
        purchaseOrder.supplier.email,
        emailSubject,
        emailContent
      );
    } catch (emailError) {
      console.error('Failed to send delay response email:', emailError);
    }

    const updatedPO = await PurchaseOrder.findByPk(id, {
      include: [
        { model: PurchaseRequest, as: 'purchaseRequest', attributes: ['id', 'prNumber', 'urgencyLevel'] },
        { model: Item, as: 'item', include: [{ model: Category, as: 'category' }] },
        { model: Warehouse, as: 'warehouse' },
        { model: Supplier, as: 'supplier' },
        { model: User, as: 'createdBy', attributes: ['id', 'name', 'email'] },
        { model: User, as: 'approvedBy', attributes: ['id', 'name', 'email'] }
      ]
    });

    res.json({
      success: true,
      message: `Delay request ${action}d successfully`,
      data: updatedPO
    });

  } catch (error) {
    console.error('Error processing delay request:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to process delay request',
      error: error.message
    });
  }
};

// Cancel purchase order (Admin only)
exports.cancelPurchaseOrder = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body; // Reason required for cancellation

    const purchaseOrder = await PurchaseOrder.findByPk(id);
    if (!purchaseOrder) {
      return res.status(404).json({
        success: false,
        message: 'Purchase order not found'
      });
    }

    // Check if PO can be cancelled
    if (['completed', 'cancelled'].includes(purchaseOrder.status)) {
      return res.status(400).json({
        success: false,
        message: 'Cannot cancel purchase order in current status'
      });
    }

    // Require reason for cancellation (audit trail)
    if (!reason) {
      return res.status(400).json({
        success: false,
        message: 'Reason is required for cancelling purchase order'
      });
    }

    // Log admin action
    console.log(`ðŸš« Admin Cancel: ${req.user.name} cancelled PO ${purchaseOrder.poNumber} - Reason: ${reason}`);

    await purchaseOrder.update({
      status: 'cancelled',
      notes: `${purchaseOrder.notes || ''}\n\nCANCELLED by ${req.user.name}: ${reason}`,
      approvedById: req.user.id,
      approvedAt: new Date()
    });

    // If PO was sent to supplier, send cancellation email
    if (purchaseOrder.status === 'sent' || purchaseOrder.status === 'acknowledged') {
      try {
        const sendEmail = require('../utils/sendEmail');
        const fullPO = await PurchaseOrder.findByPk(id, {
          include: [
            { model: Supplier, as: 'supplier' },
            { model: Item, as: 'item' }
          ]
        });

        if (fullPO && fullPO.supplier) {
          await sendEmail(
            fullPO.supplier.email,
            `PO Cancellation - ${fullPO.poNumber}`,
            `
            Dear ${fullPO.supplier.name},
            
            Purchase Order ${fullPO.poNumber} has been CANCELLED.
            
            Cancellation Reason: ${reason}
            
            Please disregard any previous communications regarding this order.
            
            Best regards,
            IMRAS Procurement Team
            `
          );
        }
      } catch (emailError) {
        console.error('Failed to send cancellation email:', emailError);
        // Don't fail the cancellation if email fails
      }
    }

    const updatedPO = await PurchaseOrder.findByPk(id, {
      include: [
        {
          model: PurchaseRequest,
          as: 'purchaseRequest',
          attributes: ['id', 'prNumber', 'urgencyLevel']
        },
        {
          model: Item,
          as: 'item',
          include: [{ model: Category, as: 'category' }]
        },
        {
          model: Warehouse,
          as: 'warehouse'
        },
        {
          model: Supplier,
          as: 'supplier'
        },
        {
          model: User,
          as: 'createdBy',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'approvedBy',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    res.json({
      success: true,
      message: 'Purchase order cancelled successfully',
      data: updatedPO
    });

  } catch (error) {
    console.error('Error cancelling purchase order:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to cancel purchase order',
      error: error.message
    });
  }
};